/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 3.12.4
 * source: apps/room/proto/room.proto
 * git: https://github.com/thesayyn/protoc-gen-ts
 * buymeacoffee: https://www.buymeacoffee.com/thesayyn
 *  */
import * as pb_1 from "google-protobuf";
import * as grpc_1 from "@grpc/grpc-js";
export namespace room {
    export enum ErrorType {
        None = 0,
        UnkownError = 1,
        PermissionDenied = 2,
        ServiceUnavailable = 3,
        RoomLocked = 4,
        PasswordRequired = 5,
        RoomAlreadyExist = 6,
        RoomNotExist = 7,
        InvalidParams = 8,
        PeerAlreadyExist = 9,
        PeerNotExist = 10
    }
    export enum Role {
        Host = 0,
        Guest = 1
    }
    export enum Protocol {
        ProtocolUnknown = 0,
        WebRTC = 1,
        SIP = 2,
        RTMP = 3,
        RTSP = 4
    }
    export enum PeerState {
        JOIN = 0,
        UPDATE = 1,
        LEAVE = 2
    }
    export class Error extends pb_1.Message {
        constructor(data?: any[] | {
            code?: ErrorType;
            reason?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("code" in data && data.code != undefined) {
                    this.code = data.code;
                }
                if ("reason" in data && data.reason != undefined) {
                    this.reason = data.reason;
                }
            }
        }
        get code() {
            return pb_1.Message.getField(this, 1) as ErrorType;
        }
        set code(value: ErrorType) {
            pb_1.Message.setField(this, 1, value);
        }
        get reason() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set reason(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        toObject() {
            const data: {
                code?: ErrorType;
                reason?: string;
            } = {};
            if (this.code != null) {
                data.code = this.code;
            }
            if (this.reason != null) {
                data.reason = this.reason;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.code !== undefined)
                writer.writeEnum(1, this.code);
            if (typeof this.reason === "string" && this.reason.length)
                writer.writeString(2, this.reason);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Error {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Error();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.code = reader.readEnum();
                        break;
                    case 2:
                        message.reason = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Error {
            return Error.deserialize(bytes);
        }
    }
    export class Request extends pb_1.Message {
        constructor(data?: any[] | ({} & (({
            join?: JoinRequest;
            leave?: never;
            sendMessage?: never;
        } | {
            join?: never;
            leave?: LeaveRequest;
            sendMessage?: never;
        } | {
            join?: never;
            leave?: never;
            sendMessage?: SendMessageRequest;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], [[1, 2, 3]]);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("join" in data && data.join != undefined) {
                    this.join = data.join;
                }
                if ("leave" in data && data.leave != undefined) {
                    this.leave = data.leave;
                }
                if ("sendMessage" in data && data.sendMessage != undefined) {
                    this.sendMessage = data.sendMessage;
                }
            }
        }
        get join() {
            return pb_1.Message.getWrapperField(this, JoinRequest, 1) as JoinRequest;
        }
        set join(value: JoinRequest) {
            pb_1.Message.setOneofWrapperField(this, 1, [1, 2, 3], value);
        }
        get leave() {
            return pb_1.Message.getWrapperField(this, LeaveRequest, 2) as LeaveRequest;
        }
        set leave(value: LeaveRequest) {
            pb_1.Message.setOneofWrapperField(this, 2, [1, 2, 3], value);
        }
        get sendMessage() {
            return pb_1.Message.getWrapperField(this, SendMessageRequest, 3) as SendMessageRequest;
        }
        set sendMessage(value: SendMessageRequest) {
            pb_1.Message.setOneofWrapperField(this, 3, [1, 2, 3], value);
        }
        get payload() {
            const cases: {
                [index: number]: "none" | "join" | "leave" | "sendMessage";
            } = {
                0: "none",
                1: "join",
                2: "leave",
                3: "sendMessage"
            };
            return cases[pb_1.Message.computeOneofCase(this, [1, 2, 3])];
        }
        toObject() {
            const data: {
                join?: ReturnType<typeof JoinRequest.prototype.toObject>;
                leave?: ReturnType<typeof LeaveRequest.prototype.toObject>;
                sendMessage?: ReturnType<typeof SendMessageRequest.prototype.toObject>;
            } = {};
            if (this.join != null) {
                data.join = this.join.toObject();
            }
            if (this.leave != null) {
                data.leave = this.leave.toObject();
            }
            if (this.sendMessage != null) {
                data.sendMessage = this.sendMessage.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.join !== undefined)
                writer.writeMessage(1, this.join, () => this.join.serialize(writer));
            if (this.leave !== undefined)
                writer.writeMessage(2, this.leave, () => this.leave.serialize(writer));
            if (this.sendMessage !== undefined)
                writer.writeMessage(3, this.sendMessage, () => this.sendMessage.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Request {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Request();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.join, () => message.join = JoinRequest.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.leave, () => message.leave = LeaveRequest.deserialize(reader));
                        break;
                    case 3:
                        reader.readMessage(message.sendMessage, () => message.sendMessage = SendMessageRequest.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Request {
            return Request.deserialize(bytes);
        }
    }
    export class Reply extends pb_1.Message {
        constructor(data?: any[] | ({} & (({
            join?: JoinReply;
            leave?: never;
            sendMessage?: never;
            Peer?: never;
            message?: never;
            disconnect?: never;
            room?: never;
        } | {
            join?: never;
            leave?: LeaveReply;
            sendMessage?: never;
            Peer?: never;
            message?: never;
            disconnect?: never;
            room?: never;
        } | {
            join?: never;
            leave?: never;
            sendMessage?: SendMessageReply;
            Peer?: never;
            message?: never;
            disconnect?: never;
            room?: never;
        } | {
            join?: never;
            leave?: never;
            sendMessage?: never;
            Peer?: PeerEvent;
            message?: never;
            disconnect?: never;
            room?: never;
        } | {
            join?: never;
            leave?: never;
            sendMessage?: never;
            Peer?: never;
            message?: Message;
            disconnect?: never;
            room?: never;
        } | {
            join?: never;
            leave?: never;
            sendMessage?: never;
            Peer?: never;
            message?: never;
            disconnect?: Disconnect;
            room?: never;
        } | {
            join?: never;
            leave?: never;
            sendMessage?: never;
            Peer?: never;
            message?: never;
            disconnect?: never;
            room?: Room;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], [[1, 2, 3, 4, 5, 6, 7]]);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("join" in data && data.join != undefined) {
                    this.join = data.join;
                }
                if ("leave" in data && data.leave != undefined) {
                    this.leave = data.leave;
                }
                if ("sendMessage" in data && data.sendMessage != undefined) {
                    this.sendMessage = data.sendMessage;
                }
                if ("Peer" in data && data.Peer != undefined) {
                    this.Peer = data.Peer;
                }
                if ("message" in data && data.message != undefined) {
                    this.message = data.message;
                }
                if ("disconnect" in data && data.disconnect != undefined) {
                    this.disconnect = data.disconnect;
                }
                if ("room" in data && data.room != undefined) {
                    this.room = data.room;
                }
            }
        }
        get join() {
            return pb_1.Message.getWrapperField(this, JoinReply, 1) as JoinReply;
        }
        set join(value: JoinReply) {
            pb_1.Message.setOneofWrapperField(this, 1, [1, 2, 3, 4, 5, 6, 7], value);
        }
        get leave() {
            return pb_1.Message.getWrapperField(this, LeaveReply, 2) as LeaveReply;
        }
        set leave(value: LeaveReply) {
            pb_1.Message.setOneofWrapperField(this, 2, [1, 2, 3, 4, 5, 6, 7], value);
        }
        get sendMessage() {
            return pb_1.Message.getWrapperField(this, SendMessageReply, 3) as SendMessageReply;
        }
        set sendMessage(value: SendMessageReply) {
            pb_1.Message.setOneofWrapperField(this, 3, [1, 2, 3, 4, 5, 6, 7], value);
        }
        get Peer() {
            return pb_1.Message.getWrapperField(this, PeerEvent, 4) as PeerEvent;
        }
        set Peer(value: PeerEvent) {
            pb_1.Message.setOneofWrapperField(this, 4, [1, 2, 3, 4, 5, 6, 7], value);
        }
        get message() {
            return pb_1.Message.getWrapperField(this, Message, 5) as Message;
        }
        set message(value: Message) {
            pb_1.Message.setOneofWrapperField(this, 5, [1, 2, 3, 4, 5, 6, 7], value);
        }
        get disconnect() {
            return pb_1.Message.getWrapperField(this, Disconnect, 6) as Disconnect;
        }
        set disconnect(value: Disconnect) {
            pb_1.Message.setOneofWrapperField(this, 6, [1, 2, 3, 4, 5, 6, 7], value);
        }
        get room() {
            return pb_1.Message.getWrapperField(this, Room, 7) as Room;
        }
        set room(value: Room) {
            pb_1.Message.setOneofWrapperField(this, 7, [1, 2, 3, 4, 5, 6, 7], value);
        }
        get payload() {
            const cases: {
                [index: number]: "none" | "join" | "leave" | "sendMessage" | "Peer" | "message" | "disconnect" | "room";
            } = {
                0: "none",
                1: "join",
                2: "leave",
                3: "sendMessage",
                4: "Peer",
                5: "message",
                6: "disconnect",
                7: "room"
            };
            return cases[pb_1.Message.computeOneofCase(this, [1, 2, 3, 4, 5, 6, 7])];
        }
        toObject() {
            const data: {
                join?: ReturnType<typeof JoinReply.prototype.toObject>;
                leave?: ReturnType<typeof LeaveReply.prototype.toObject>;
                sendMessage?: ReturnType<typeof SendMessageReply.prototype.toObject>;
                Peer?: ReturnType<typeof PeerEvent.prototype.toObject>;
                message?: ReturnType<typeof Message.prototype.toObject>;
                disconnect?: ReturnType<typeof Disconnect.prototype.toObject>;
                room?: ReturnType<typeof Room.prototype.toObject>;
            } = {};
            if (this.join != null) {
                data.join = this.join.toObject();
            }
            if (this.leave != null) {
                data.leave = this.leave.toObject();
            }
            if (this.sendMessage != null) {
                data.sendMessage = this.sendMessage.toObject();
            }
            if (this.Peer != null) {
                data.Peer = this.Peer.toObject();
            }
            if (this.message != null) {
                data.message = this.message.toObject();
            }
            if (this.disconnect != null) {
                data.disconnect = this.disconnect.toObject();
            }
            if (this.room != null) {
                data.room = this.room.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.join !== undefined)
                writer.writeMessage(1, this.join, () => this.join.serialize(writer));
            if (this.leave !== undefined)
                writer.writeMessage(2, this.leave, () => this.leave.serialize(writer));
            if (this.sendMessage !== undefined)
                writer.writeMessage(3, this.sendMessage, () => this.sendMessage.serialize(writer));
            if (this.Peer !== undefined)
                writer.writeMessage(4, this.Peer, () => this.Peer.serialize(writer));
            if (this.message !== undefined)
                writer.writeMessage(5, this.message, () => this.message.serialize(writer));
            if (this.disconnect !== undefined)
                writer.writeMessage(6, this.disconnect, () => this.disconnect.serialize(writer));
            if (this.room !== undefined)
                writer.writeMessage(7, this.room, () => this.room.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Reply {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Reply();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.join, () => message.join = JoinReply.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.leave, () => message.leave = LeaveReply.deserialize(reader));
                        break;
                    case 3:
                        reader.readMessage(message.sendMessage, () => message.sendMessage = SendMessageReply.deserialize(reader));
                        break;
                    case 4:
                        reader.readMessage(message.Peer, () => message.Peer = PeerEvent.deserialize(reader));
                        break;
                    case 5:
                        reader.readMessage(message.message, () => message.message = Message.deserialize(reader));
                        break;
                    case 6:
                        reader.readMessage(message.disconnect, () => message.disconnect = Disconnect.deserialize(reader));
                        break;
                    case 7:
                        reader.readMessage(message.room, () => message.room = Room.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Reply {
            return Reply.deserialize(bytes);
        }
    }
    export class CreateRoomRequest extends pb_1.Message {
        constructor(data?: any[] | {
            room?: Room;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("room" in data && data.room != undefined) {
                    this.room = data.room;
                }
            }
        }
        get room() {
            return pb_1.Message.getWrapperField(this, Room, 1) as Room;
        }
        set room(value: Room) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        toObject() {
            const data: {
                room?: ReturnType<typeof Room.prototype.toObject>;
            } = {};
            if (this.room != null) {
                data.room = this.room.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.room !== undefined)
                writer.writeMessage(1, this.room, () => this.room.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CreateRoomRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new CreateRoomRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.room, () => message.room = Room.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): CreateRoomRequest {
            return CreateRoomRequest.deserialize(bytes);
        }
    }
    export class CreateRoomReply extends pb_1.Message {
        constructor(data?: any[] | {
            success?: boolean;
            error?: Error;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("success" in data && data.success != undefined) {
                    this.success = data.success;
                }
                if ("error" in data && data.error != undefined) {
                    this.error = data.error;
                }
            }
        }
        get success() {
            return pb_1.Message.getField(this, 1) as boolean;
        }
        set success(value: boolean) {
            pb_1.Message.setField(this, 1, value);
        }
        get error() {
            return pb_1.Message.getWrapperField(this, Error, 2) as Error;
        }
        set error(value: Error) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        toObject() {
            const data: {
                success?: boolean;
                error?: ReturnType<typeof Error.prototype.toObject>;
            } = {};
            if (this.success != null) {
                data.success = this.success;
            }
            if (this.error != null) {
                data.error = this.error.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.success !== undefined)
                writer.writeBool(1, this.success);
            if (this.error !== undefined)
                writer.writeMessage(2, this.error, () => this.error.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CreateRoomReply {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new CreateRoomReply();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.success = reader.readBool();
                        break;
                    case 2:
                        reader.readMessage(message.error, () => message.error = Error.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): CreateRoomReply {
            return CreateRoomReply.deserialize(bytes);
        }
    }
    export class DeleteRoomRequest extends pb_1.Message {
        constructor(data?: any[] | {
            sid?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("sid" in data && data.sid != undefined) {
                    this.sid = data.sid;
                }
            }
        }
        get sid() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set sid(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        toObject() {
            const data: {
                sid?: string;
            } = {};
            if (this.sid != null) {
                data.sid = this.sid;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.sid === "string" && this.sid.length)
                writer.writeString(1, this.sid);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): DeleteRoomRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new DeleteRoomRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.sid = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): DeleteRoomRequest {
            return DeleteRoomRequest.deserialize(bytes);
        }
    }
    export class DeleteRoomReply extends pb_1.Message {
        constructor(data?: any[] | {
            success?: boolean;
            error?: Error;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("success" in data && data.success != undefined) {
                    this.success = data.success;
                }
                if ("error" in data && data.error != undefined) {
                    this.error = data.error;
                }
            }
        }
        get success() {
            return pb_1.Message.getField(this, 1) as boolean;
        }
        set success(value: boolean) {
            pb_1.Message.setField(this, 1, value);
        }
        get error() {
            return pb_1.Message.getWrapperField(this, Error, 2) as Error;
        }
        set error(value: Error) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        toObject() {
            const data: {
                success?: boolean;
                error?: ReturnType<typeof Error.prototype.toObject>;
            } = {};
            if (this.success != null) {
                data.success = this.success;
            }
            if (this.error != null) {
                data.error = this.error.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.success !== undefined)
                writer.writeBool(1, this.success);
            if (this.error !== undefined)
                writer.writeMessage(2, this.error, () => this.error.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): DeleteRoomReply {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new DeleteRoomReply();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.success = reader.readBool();
                        break;
                    case 2:
                        reader.readMessage(message.error, () => message.error = Error.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): DeleteRoomReply {
            return DeleteRoomReply.deserialize(bytes);
        }
    }
    export class JoinRequest extends pb_1.Message {
        constructor(data?: any[] | {
            peer?: Peer;
            password?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("peer" in data && data.peer != undefined) {
                    this.peer = data.peer;
                }
                if ("password" in data && data.password != undefined) {
                    this.password = data.password;
                }
            }
        }
        get peer() {
            return pb_1.Message.getWrapperField(this, Peer, 1) as Peer;
        }
        set peer(value: Peer) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get password() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set password(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        toObject() {
            const data: {
                peer?: ReturnType<typeof Peer.prototype.toObject>;
                password?: string;
            } = {};
            if (this.peer != null) {
                data.peer = this.peer.toObject();
            }
            if (this.password != null) {
                data.password = this.password;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.peer !== undefined)
                writer.writeMessage(1, this.peer, () => this.peer.serialize(writer));
            if (typeof this.password === "string" && this.password.length)
                writer.writeString(2, this.password);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): JoinRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new JoinRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.peer, () => message.peer = Peer.deserialize(reader));
                        break;
                    case 2:
                        message.password = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): JoinRequest {
            return JoinRequest.deserialize(bytes);
        }
    }
    export class Room extends pb_1.Message {
        constructor(data?: any[] | {
            sid?: string;
            name?: string;
            lock?: boolean;
            password?: string;
            description?: string;
            maxPeers?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("sid" in data && data.sid != undefined) {
                    this.sid = data.sid;
                }
                if ("name" in data && data.name != undefined) {
                    this.name = data.name;
                }
                if ("lock" in data && data.lock != undefined) {
                    this.lock = data.lock;
                }
                if ("password" in data && data.password != undefined) {
                    this.password = data.password;
                }
                if ("description" in data && data.description != undefined) {
                    this.description = data.description;
                }
                if ("maxPeers" in data && data.maxPeers != undefined) {
                    this.maxPeers = data.maxPeers;
                }
            }
        }
        get sid() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set sid(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get name() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set name(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get lock() {
            return pb_1.Message.getField(this, 3) as boolean;
        }
        set lock(value: boolean) {
            pb_1.Message.setField(this, 3, value);
        }
        get password() {
            return pb_1.Message.getField(this, 4) as string;
        }
        set password(value: string) {
            pb_1.Message.setField(this, 4, value);
        }
        get description() {
            return pb_1.Message.getField(this, 5) as string;
        }
        set description(value: string) {
            pb_1.Message.setField(this, 5, value);
        }
        get maxPeers() {
            return pb_1.Message.getField(this, 6) as number;
        }
        set maxPeers(value: number) {
            pb_1.Message.setField(this, 6, value);
        }
        toObject() {
            const data: {
                sid?: string;
                name?: string;
                lock?: boolean;
                password?: string;
                description?: string;
                maxPeers?: number;
            } = {};
            if (this.sid != null) {
                data.sid = this.sid;
            }
            if (this.name != null) {
                data.name = this.name;
            }
            if (this.lock != null) {
                data.lock = this.lock;
            }
            if (this.password != null) {
                data.password = this.password;
            }
            if (this.description != null) {
                data.description = this.description;
            }
            if (this.maxPeers != null) {
                data.maxPeers = this.maxPeers;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.sid === "string" && this.sid.length)
                writer.writeString(1, this.sid);
            if (typeof this.name === "string" && this.name.length)
                writer.writeString(2, this.name);
            if (this.lock !== undefined)
                writer.writeBool(3, this.lock);
            if (typeof this.password === "string" && this.password.length)
                writer.writeString(4, this.password);
            if (typeof this.description === "string" && this.description.length)
                writer.writeString(5, this.description);
            if (this.maxPeers !== undefined)
                writer.writeUint32(6, this.maxPeers);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Room {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Room();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.sid = reader.readString();
                        break;
                    case 2:
                        message.name = reader.readString();
                        break;
                    case 3:
                        message.lock = reader.readBool();
                        break;
                    case 4:
                        message.password = reader.readString();
                        break;
                    case 5:
                        message.description = reader.readString();
                        break;
                    case 6:
                        message.maxPeers = reader.readUint32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Room {
            return Room.deserialize(bytes);
        }
    }
    export class JoinReply extends pb_1.Message {
        constructor(data?: any[] | {
            success?: boolean;
            error?: Error;
            role?: Role;
            room?: Room;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("success" in data && data.success != undefined) {
                    this.success = data.success;
                }
                if ("error" in data && data.error != undefined) {
                    this.error = data.error;
                }
                if ("role" in data && data.role != undefined) {
                    this.role = data.role;
                }
                if ("room" in data && data.room != undefined) {
                    this.room = data.room;
                }
            }
        }
        get success() {
            return pb_1.Message.getField(this, 1) as boolean;
        }
        set success(value: boolean) {
            pb_1.Message.setField(this, 1, value);
        }
        get error() {
            return pb_1.Message.getWrapperField(this, Error, 2) as Error;
        }
        set error(value: Error) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get role() {
            return pb_1.Message.getField(this, 3) as Role;
        }
        set role(value: Role) {
            pb_1.Message.setField(this, 3, value);
        }
        get room() {
            return pb_1.Message.getWrapperField(this, Room, 4) as Room;
        }
        set room(value: Room) {
            pb_1.Message.setWrapperField(this, 4, value);
        }
        toObject() {
            const data: {
                success?: boolean;
                error?: ReturnType<typeof Error.prototype.toObject>;
                role?: Role;
                room?: ReturnType<typeof Room.prototype.toObject>;
            } = {};
            if (this.success != null) {
                data.success = this.success;
            }
            if (this.error != null) {
                data.error = this.error.toObject();
            }
            if (this.role != null) {
                data.role = this.role;
            }
            if (this.room != null) {
                data.room = this.room.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.success !== undefined)
                writer.writeBool(1, this.success);
            if (this.error !== undefined)
                writer.writeMessage(2, this.error, () => this.error.serialize(writer));
            if (this.role !== undefined)
                writer.writeEnum(3, this.role);
            if (this.room !== undefined)
                writer.writeMessage(4, this.room, () => this.room.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): JoinReply {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new JoinReply();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.success = reader.readBool();
                        break;
                    case 2:
                        reader.readMessage(message.error, () => message.error = Error.deserialize(reader));
                        break;
                    case 3:
                        message.role = reader.readEnum();
                        break;
                    case 4:
                        reader.readMessage(message.room, () => message.room = Room.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): JoinReply {
            return JoinReply.deserialize(bytes);
        }
    }
    export class LeaveRequest extends pb_1.Message {
        constructor(data?: any[] | {
            sid?: string;
            uid?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("sid" in data && data.sid != undefined) {
                    this.sid = data.sid;
                }
                if ("uid" in data && data.uid != undefined) {
                    this.uid = data.uid;
                }
            }
        }
        get sid() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set sid(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get uid() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set uid(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        toObject() {
            const data: {
                sid?: string;
                uid?: string;
            } = {};
            if (this.sid != null) {
                data.sid = this.sid;
            }
            if (this.uid != null) {
                data.uid = this.uid;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.sid === "string" && this.sid.length)
                writer.writeString(1, this.sid);
            if (typeof this.uid === "string" && this.uid.length)
                writer.writeString(2, this.uid);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): LeaveRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new LeaveRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.sid = reader.readString();
                        break;
                    case 2:
                        message.uid = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): LeaveRequest {
            return LeaveRequest.deserialize(bytes);
        }
    }
    export class LeaveReply extends pb_1.Message {
        constructor(data?: any[] | {
            success?: boolean;
            error?: Error;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("success" in data && data.success != undefined) {
                    this.success = data.success;
                }
                if ("error" in data && data.error != undefined) {
                    this.error = data.error;
                }
            }
        }
        get success() {
            return pb_1.Message.getField(this, 1) as boolean;
        }
        set success(value: boolean) {
            pb_1.Message.setField(this, 1, value);
        }
        get error() {
            return pb_1.Message.getWrapperField(this, Error, 2) as Error;
        }
        set error(value: Error) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        toObject() {
            const data: {
                success?: boolean;
                error?: ReturnType<typeof Error.prototype.toObject>;
            } = {};
            if (this.success != null) {
                data.success = this.success;
            }
            if (this.error != null) {
                data.error = this.error.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.success !== undefined)
                writer.writeBool(1, this.success);
            if (this.error !== undefined)
                writer.writeMessage(2, this.error, () => this.error.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): LeaveReply {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new LeaveReply();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.success = reader.readBool();
                        break;
                    case 2:
                        reader.readMessage(message.error, () => message.error = Error.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): LeaveReply {
            return LeaveReply.deserialize(bytes);
        }
    }
    export class Peer extends pb_1.Message {
        constructor(data?: any[] | {
            sid?: string;
            uid?: string;
            displayName?: string;
            extraInfo?: Uint8Array;
            destination?: string;
            role?: Role;
            protocol?: Protocol;
            avatar?: string;
            direction?: Peer.Direction;
            vendor?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("sid" in data && data.sid != undefined) {
                    this.sid = data.sid;
                }
                if ("uid" in data && data.uid != undefined) {
                    this.uid = data.uid;
                }
                if ("displayName" in data && data.displayName != undefined) {
                    this.displayName = data.displayName;
                }
                if ("extraInfo" in data && data.extraInfo != undefined) {
                    this.extraInfo = data.extraInfo;
                }
                if ("destination" in data && data.destination != undefined) {
                    this.destination = data.destination;
                }
                if ("role" in data && data.role != undefined) {
                    this.role = data.role;
                }
                if ("protocol" in data && data.protocol != undefined) {
                    this.protocol = data.protocol;
                }
                if ("avatar" in data && data.avatar != undefined) {
                    this.avatar = data.avatar;
                }
                if ("direction" in data && data.direction != undefined) {
                    this.direction = data.direction;
                }
                if ("vendor" in data && data.vendor != undefined) {
                    this.vendor = data.vendor;
                }
            }
        }
        get sid() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set sid(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get uid() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set uid(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get displayName() {
            return pb_1.Message.getField(this, 3) as string;
        }
        set displayName(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get extraInfo() {
            return pb_1.Message.getField(this, 4) as Uint8Array;
        }
        set extraInfo(value: Uint8Array) {
            pb_1.Message.setField(this, 4, value);
        }
        get destination() {
            return pb_1.Message.getField(this, 5) as string;
        }
        set destination(value: string) {
            pb_1.Message.setField(this, 5, value);
        }
        get role() {
            return pb_1.Message.getField(this, 6) as Role;
        }
        set role(value: Role) {
            pb_1.Message.setField(this, 6, value);
        }
        get protocol() {
            return pb_1.Message.getField(this, 7) as Protocol;
        }
        set protocol(value: Protocol) {
            pb_1.Message.setField(this, 7, value);
        }
        get avatar() {
            return pb_1.Message.getField(this, 8) as string;
        }
        set avatar(value: string) {
            pb_1.Message.setField(this, 8, value);
        }
        get direction() {
            return pb_1.Message.getField(this, 9) as Peer.Direction;
        }
        set direction(value: Peer.Direction) {
            pb_1.Message.setField(this, 9, value);
        }
        get vendor() {
            return pb_1.Message.getField(this, 10) as string;
        }
        set vendor(value: string) {
            pb_1.Message.setField(this, 10, value);
        }
        toObject() {
            const data: {
                sid?: string;
                uid?: string;
                displayName?: string;
                extraInfo?: Uint8Array;
                destination?: string;
                role?: Role;
                protocol?: Protocol;
                avatar?: string;
                direction?: Peer.Direction;
                vendor?: string;
            } = {};
            if (this.sid != null) {
                data.sid = this.sid;
            }
            if (this.uid != null) {
                data.uid = this.uid;
            }
            if (this.displayName != null) {
                data.displayName = this.displayName;
            }
            if (this.extraInfo != null) {
                data.extraInfo = this.extraInfo;
            }
            if (this.destination != null) {
                data.destination = this.destination;
            }
            if (this.role != null) {
                data.role = this.role;
            }
            if (this.protocol != null) {
                data.protocol = this.protocol;
            }
            if (this.avatar != null) {
                data.avatar = this.avatar;
            }
            if (this.direction != null) {
                data.direction = this.direction;
            }
            if (this.vendor != null) {
                data.vendor = this.vendor;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.sid === "string" && this.sid.length)
                writer.writeString(1, this.sid);
            if (typeof this.uid === "string" && this.uid.length)
                writer.writeString(2, this.uid);
            if (typeof this.displayName === "string" && this.displayName.length)
                writer.writeString(3, this.displayName);
            if (this.extraInfo !== undefined)
                writer.writeBytes(4, this.extraInfo);
            if (typeof this.destination === "string" && this.destination.length)
                writer.writeString(5, this.destination);
            if (this.role !== undefined)
                writer.writeEnum(6, this.role);
            if (this.protocol !== undefined)
                writer.writeEnum(7, this.protocol);
            if (typeof this.avatar === "string" && this.avatar.length)
                writer.writeString(8, this.avatar);
            if (this.direction !== undefined)
                writer.writeEnum(9, this.direction);
            if (typeof this.vendor === "string" && this.vendor.length)
                writer.writeString(10, this.vendor);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Peer {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Peer();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.sid = reader.readString();
                        break;
                    case 2:
                        message.uid = reader.readString();
                        break;
                    case 3:
                        message.displayName = reader.readString();
                        break;
                    case 4:
                        message.extraInfo = reader.readBytes();
                        break;
                    case 5:
                        message.destination = reader.readString();
                        break;
                    case 6:
                        message.role = reader.readEnum();
                        break;
                    case 7:
                        message.protocol = reader.readEnum();
                        break;
                    case 8:
                        message.avatar = reader.readString();
                        break;
                    case 9:
                        message.direction = reader.readEnum();
                        break;
                    case 10:
                        message.vendor = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Peer {
            return Peer.deserialize(bytes);
        }
    }
    export namespace Peer {
        export enum Direction {
            INCOMING = 0,
            OUTGOING = 1,
            BILATERAL = 2
        }
    }
    export class AddPeerRequest extends pb_1.Message {
        constructor(data?: any[] | {
            peer?: Peer;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("peer" in data && data.peer != undefined) {
                    this.peer = data.peer;
                }
            }
        }
        get peer() {
            return pb_1.Message.getWrapperField(this, Peer, 1) as Peer;
        }
        set peer(value: Peer) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        toObject() {
            const data: {
                peer?: ReturnType<typeof Peer.prototype.toObject>;
            } = {};
            if (this.peer != null) {
                data.peer = this.peer.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.peer !== undefined)
                writer.writeMessage(1, this.peer, () => this.peer.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): AddPeerRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new AddPeerRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.peer, () => message.peer = Peer.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): AddPeerRequest {
            return AddPeerRequest.deserialize(bytes);
        }
    }
    export class AddPeerReply extends pb_1.Message {
        constructor(data?: any[] | {
            success?: boolean;
            error?: Error;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("success" in data && data.success != undefined) {
                    this.success = data.success;
                }
                if ("error" in data && data.error != undefined) {
                    this.error = data.error;
                }
            }
        }
        get success() {
            return pb_1.Message.getField(this, 1) as boolean;
        }
        set success(value: boolean) {
            pb_1.Message.setField(this, 1, value);
        }
        get error() {
            return pb_1.Message.getWrapperField(this, Error, 2) as Error;
        }
        set error(value: Error) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        toObject() {
            const data: {
                success?: boolean;
                error?: ReturnType<typeof Error.prototype.toObject>;
            } = {};
            if (this.success != null) {
                data.success = this.success;
            }
            if (this.error != null) {
                data.error = this.error.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.success !== undefined)
                writer.writeBool(1, this.success);
            if (this.error !== undefined)
                writer.writeMessage(2, this.error, () => this.error.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): AddPeerReply {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new AddPeerReply();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.success = reader.readBool();
                        break;
                    case 2:
                        reader.readMessage(message.error, () => message.error = Error.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): AddPeerReply {
            return AddPeerReply.deserialize(bytes);
        }
    }
    export class GetPeersRequest extends pb_1.Message {
        constructor(data?: any[] | {
            sid?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("sid" in data && data.sid != undefined) {
                    this.sid = data.sid;
                }
            }
        }
        get sid() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set sid(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        toObject() {
            const data: {
                sid?: string;
            } = {};
            if (this.sid != null) {
                data.sid = this.sid;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.sid === "string" && this.sid.length)
                writer.writeString(1, this.sid);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): GetPeersRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new GetPeersRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.sid = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): GetPeersRequest {
            return GetPeersRequest.deserialize(bytes);
        }
    }
    export class GetPeersReply extends pb_1.Message {
        constructor(data?: any[] | {
            success?: boolean;
            error?: Error;
            Peers?: Peer[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [3], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("success" in data && data.success != undefined) {
                    this.success = data.success;
                }
                if ("error" in data && data.error != undefined) {
                    this.error = data.error;
                }
                if ("Peers" in data && data.Peers != undefined) {
                    this.Peers = data.Peers;
                }
            }
        }
        get success() {
            return pb_1.Message.getField(this, 1) as boolean;
        }
        set success(value: boolean) {
            pb_1.Message.setField(this, 1, value);
        }
        get error() {
            return pb_1.Message.getWrapperField(this, Error, 2) as Error;
        }
        set error(value: Error) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get Peers() {
            return pb_1.Message.getRepeatedWrapperField(this, Peer, 3) as Peer[];
        }
        set Peers(value: Peer[]) {
            pb_1.Message.setRepeatedWrapperField(this, 3, value);
        }
        toObject() {
            const data: {
                success?: boolean;
                error?: ReturnType<typeof Error.prototype.toObject>;
                Peers?: ReturnType<typeof Peer.prototype.toObject>[];
            } = {};
            if (this.success != null) {
                data.success = this.success;
            }
            if (this.error != null) {
                data.error = this.error.toObject();
            }
            if (this.Peers != null) {
                data.Peers = this.Peers.map((item: Peer) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.success !== undefined)
                writer.writeBool(1, this.success);
            if (this.error !== undefined)
                writer.writeMessage(2, this.error, () => this.error.serialize(writer));
            if (this.Peers !== undefined)
                writer.writeRepeatedMessage(3, this.Peers, (item: Peer) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): GetPeersReply {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new GetPeersReply();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.success = reader.readBool();
                        break;
                    case 2:
                        reader.readMessage(message.error, () => message.error = Error.deserialize(reader));
                        break;
                    case 3:
                        reader.readMessage(message.Peers, () => pb_1.Message.addToRepeatedWrapperField(message, 3, Peer.deserialize(reader), Peer));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): GetPeersReply {
            return GetPeersReply.deserialize(bytes);
        }
    }
    export class Message extends pb_1.Message {
        constructor(data?: any[] | {
            from?: string;
            to?: string;
            type?: string;
            payload?: Uint8Array;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("from" in data && data.from != undefined) {
                    this.from = data.from;
                }
                if ("to" in data && data.to != undefined) {
                    this.to = data.to;
                }
                if ("type" in data && data.type != undefined) {
                    this.type = data.type;
                }
                if ("payload" in data && data.payload != undefined) {
                    this.payload = data.payload;
                }
            }
        }
        get from() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set from(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get to() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set to(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get type() {
            return pb_1.Message.getField(this, 3) as string;
        }
        set type(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get payload() {
            return pb_1.Message.getField(this, 4) as Uint8Array;
        }
        set payload(value: Uint8Array) {
            pb_1.Message.setField(this, 4, value);
        }
        toObject() {
            const data: {
                from?: string;
                to?: string;
                type?: string;
                payload?: Uint8Array;
            } = {};
            if (this.from != null) {
                data.from = this.from;
            }
            if (this.to != null) {
                data.to = this.to;
            }
            if (this.type != null) {
                data.type = this.type;
            }
            if (this.payload != null) {
                data.payload = this.payload;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.from === "string" && this.from.length)
                writer.writeString(1, this.from);
            if (typeof this.to === "string" && this.to.length)
                writer.writeString(2, this.to);
            if (typeof this.type === "string" && this.type.length)
                writer.writeString(3, this.type);
            if (this.payload !== undefined)
                writer.writeBytes(4, this.payload);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Message {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Message();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.from = reader.readString();
                        break;
                    case 2:
                        message.to = reader.readString();
                        break;
                    case 3:
                        message.type = reader.readString();
                        break;
                    case 4:
                        message.payload = reader.readBytes();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Message {
            return Message.deserialize(bytes);
        }
    }
    export class SendMessageRequest extends pb_1.Message {
        constructor(data?: any[] | {
            sid?: string;
            message?: Message;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("sid" in data && data.sid != undefined) {
                    this.sid = data.sid;
                }
                if ("message" in data && data.message != undefined) {
                    this.message = data.message;
                }
            }
        }
        get sid() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set sid(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get message() {
            return pb_1.Message.getWrapperField(this, Message, 2) as Message;
        }
        set message(value: Message) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        toObject() {
            const data: {
                sid?: string;
                message?: ReturnType<typeof Message.prototype.toObject>;
            } = {};
            if (this.sid != null) {
                data.sid = this.sid;
            }
            if (this.message != null) {
                data.message = this.message.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.sid === "string" && this.sid.length)
                writer.writeString(1, this.sid);
            if (this.message !== undefined)
                writer.writeMessage(2, this.message, () => this.message.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SendMessageRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SendMessageRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.sid = reader.readString();
                        break;
                    case 2:
                        reader.readMessage(message.message, () => message.message = Message.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SendMessageRequest {
            return SendMessageRequest.deserialize(bytes);
        }
    }
    export class SendMessageReply extends pb_1.Message {
        constructor(data?: any[] | {
            success?: boolean;
            error?: Error;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("success" in data && data.success != undefined) {
                    this.success = data.success;
                }
                if ("error" in data && data.error != undefined) {
                    this.error = data.error;
                }
            }
        }
        get success() {
            return pb_1.Message.getField(this, 1) as boolean;
        }
        set success(value: boolean) {
            pb_1.Message.setField(this, 1, value);
        }
        get error() {
            return pb_1.Message.getWrapperField(this, Error, 2) as Error;
        }
        set error(value: Error) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        toObject() {
            const data: {
                success?: boolean;
                error?: ReturnType<typeof Error.prototype.toObject>;
            } = {};
            if (this.success != null) {
                data.success = this.success;
            }
            if (this.error != null) {
                data.error = this.error.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.success !== undefined)
                writer.writeBool(1, this.success);
            if (this.error !== undefined)
                writer.writeMessage(2, this.error, () => this.error.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SendMessageReply {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SendMessageReply();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.success = reader.readBool();
                        break;
                    case 2:
                        reader.readMessage(message.error, () => message.error = Error.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SendMessageReply {
            return SendMessageReply.deserialize(bytes);
        }
    }
    export class Disconnect extends pb_1.Message {
        constructor(data?: any[] | {
            sid?: string;
            reason?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("sid" in data && data.sid != undefined) {
                    this.sid = data.sid;
                }
                if ("reason" in data && data.reason != undefined) {
                    this.reason = data.reason;
                }
            }
        }
        get sid() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set sid(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get reason() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set reason(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        toObject() {
            const data: {
                sid?: string;
                reason?: string;
            } = {};
            if (this.sid != null) {
                data.sid = this.sid;
            }
            if (this.reason != null) {
                data.reason = this.reason;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.sid === "string" && this.sid.length)
                writer.writeString(1, this.sid);
            if (typeof this.reason === "string" && this.reason.length)
                writer.writeString(2, this.reason);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Disconnect {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Disconnect();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.sid = reader.readString();
                        break;
                    case 2:
                        message.reason = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Disconnect {
            return Disconnect.deserialize(bytes);
        }
    }
    export class PeerEvent extends pb_1.Message {
        constructor(data?: any[] | {
            Peer?: Peer;
            state?: PeerState;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("Peer" in data && data.Peer != undefined) {
                    this.Peer = data.Peer;
                }
                if ("state" in data && data.state != undefined) {
                    this.state = data.state;
                }
            }
        }
        get Peer() {
            return pb_1.Message.getWrapperField(this, Peer, 1) as Peer;
        }
        set Peer(value: Peer) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get state() {
            return pb_1.Message.getField(this, 2) as PeerState;
        }
        set state(value: PeerState) {
            pb_1.Message.setField(this, 2, value);
        }
        toObject() {
            const data: {
                Peer?: ReturnType<typeof Peer.prototype.toObject>;
                state?: PeerState;
            } = {};
            if (this.Peer != null) {
                data.Peer = this.Peer.toObject();
            }
            if (this.state != null) {
                data.state = this.state;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.Peer !== undefined)
                writer.writeMessage(1, this.Peer, () => this.Peer.serialize(writer));
            if (this.state !== undefined)
                writer.writeEnum(2, this.state);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): PeerEvent {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new PeerEvent();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.Peer, () => message.Peer = Peer.deserialize(reader));
                        break;
                    case 2:
                        message.state = reader.readEnum();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): PeerEvent {
            return PeerEvent.deserialize(bytes);
        }
    }
    export class UpdateRoomRequest extends pb_1.Message {
        constructor(data?: any[] | {
            room?: Room;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("room" in data && data.room != undefined) {
                    this.room = data.room;
                }
            }
        }
        get room() {
            return pb_1.Message.getWrapperField(this, Room, 1) as Room;
        }
        set room(value: Room) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        toObject() {
            const data: {
                room?: ReturnType<typeof Room.prototype.toObject>;
            } = {};
            if (this.room != null) {
                data.room = this.room.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.room !== undefined)
                writer.writeMessage(1, this.room, () => this.room.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): UpdateRoomRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new UpdateRoomRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.room, () => message.room = Room.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): UpdateRoomRequest {
            return UpdateRoomRequest.deserialize(bytes);
        }
    }
    export class UpdateRoomReply extends pb_1.Message {
        constructor(data?: any[] | {
            success?: boolean;
            error?: Error;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("success" in data && data.success != undefined) {
                    this.success = data.success;
                }
                if ("error" in data && data.error != undefined) {
                    this.error = data.error;
                }
            }
        }
        get success() {
            return pb_1.Message.getField(this, 1) as boolean;
        }
        set success(value: boolean) {
            pb_1.Message.setField(this, 1, value);
        }
        get error() {
            return pb_1.Message.getWrapperField(this, Error, 2) as Error;
        }
        set error(value: Error) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        toObject() {
            const data: {
                success?: boolean;
                error?: ReturnType<typeof Error.prototype.toObject>;
            } = {};
            if (this.success != null) {
                data.success = this.success;
            }
            if (this.error != null) {
                data.error = this.error.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.success !== undefined)
                writer.writeBool(1, this.success);
            if (this.error !== undefined)
                writer.writeMessage(2, this.error, () => this.error.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): UpdateRoomReply {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new UpdateRoomReply();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.success = reader.readBool();
                        break;
                    case 2:
                        reader.readMessage(message.error, () => message.error = Error.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): UpdateRoomReply {
            return UpdateRoomReply.deserialize(bytes);
        }
    }
    export class EndRoomRequest extends pb_1.Message {
        constructor(data?: any[] | {
            sid?: string;
            reason?: string;
            delete?: boolean;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("sid" in data && data.sid != undefined) {
                    this.sid = data.sid;
                }
                if ("reason" in data && data.reason != undefined) {
                    this.reason = data.reason;
                }
                if ("delete" in data && data.delete != undefined) {
                    this.delete = data.delete;
                }
            }
        }
        get sid() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set sid(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get reason() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set reason(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get delete() {
            return pb_1.Message.getField(this, 3) as boolean;
        }
        set delete(value: boolean) {
            pb_1.Message.setField(this, 3, value);
        }
        toObject() {
            const data: {
                sid?: string;
                reason?: string;
                delete?: boolean;
            } = {};
            if (this.sid != null) {
                data.sid = this.sid;
            }
            if (this.reason != null) {
                data.reason = this.reason;
            }
            if (this.delete != null) {
                data.delete = this.delete;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.sid === "string" && this.sid.length)
                writer.writeString(1, this.sid);
            if (typeof this.reason === "string" && this.reason.length)
                writer.writeString(2, this.reason);
            if (this.delete !== undefined)
                writer.writeBool(3, this.delete);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): EndRoomRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new EndRoomRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.sid = reader.readString();
                        break;
                    case 2:
                        message.reason = reader.readString();
                        break;
                    case 3:
                        message.delete = reader.readBool();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): EndRoomRequest {
            return EndRoomRequest.deserialize(bytes);
        }
    }
    export class EndRoomReply extends pb_1.Message {
        constructor(data?: any[] | {
            success?: boolean;
            error?: Error;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("success" in data && data.success != undefined) {
                    this.success = data.success;
                }
                if ("error" in data && data.error != undefined) {
                    this.error = data.error;
                }
            }
        }
        get success() {
            return pb_1.Message.getField(this, 1) as boolean;
        }
        set success(value: boolean) {
            pb_1.Message.setField(this, 1, value);
        }
        get error() {
            return pb_1.Message.getWrapperField(this, Error, 2) as Error;
        }
        set error(value: Error) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        toObject() {
            const data: {
                success?: boolean;
                error?: ReturnType<typeof Error.prototype.toObject>;
            } = {};
            if (this.success != null) {
                data.success = this.success;
            }
            if (this.error != null) {
                data.error = this.error.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.success !== undefined)
                writer.writeBool(1, this.success);
            if (this.error !== undefined)
                writer.writeMessage(2, this.error, () => this.error.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): EndRoomReply {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new EndRoomReply();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.success = reader.readBool();
                        break;
                    case 2:
                        reader.readMessage(message.error, () => message.error = Error.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): EndRoomReply {
            return EndRoomReply.deserialize(bytes);
        }
    }
    export class GetRoomsRequest extends pb_1.Message {
        constructor(data?: any[] | {}) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") { }
        }
        toObject() {
            const data: {} = {};
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): GetRoomsRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new GetRoomsRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): GetRoomsRequest {
            return GetRoomsRequest.deserialize(bytes);
        }
    }
    export class GetRoomsReply extends pb_1.Message {
        constructor(data?: any[] | {
            success?: boolean;
            error?: Error;
            rooms?: Room[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [3], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("success" in data && data.success != undefined) {
                    this.success = data.success;
                }
                if ("error" in data && data.error != undefined) {
                    this.error = data.error;
                }
                if ("rooms" in data && data.rooms != undefined) {
                    this.rooms = data.rooms;
                }
            }
        }
        get success() {
            return pb_1.Message.getField(this, 1) as boolean;
        }
        set success(value: boolean) {
            pb_1.Message.setField(this, 1, value);
        }
        get error() {
            return pb_1.Message.getWrapperField(this, Error, 2) as Error;
        }
        set error(value: Error) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get rooms() {
            return pb_1.Message.getRepeatedWrapperField(this, Room, 3) as Room[];
        }
        set rooms(value: Room[]) {
            pb_1.Message.setRepeatedWrapperField(this, 3, value);
        }
        toObject() {
            const data: {
                success?: boolean;
                error?: ReturnType<typeof Error.prototype.toObject>;
                rooms?: ReturnType<typeof Room.prototype.toObject>[];
            } = {};
            if (this.success != null) {
                data.success = this.success;
            }
            if (this.error != null) {
                data.error = this.error.toObject();
            }
            if (this.rooms != null) {
                data.rooms = this.rooms.map((item: Room) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.success !== undefined)
                writer.writeBool(1, this.success);
            if (this.error !== undefined)
                writer.writeMessage(2, this.error, () => this.error.serialize(writer));
            if (this.rooms !== undefined)
                writer.writeRepeatedMessage(3, this.rooms, (item: Room) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): GetRoomsReply {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new GetRoomsReply();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.success = reader.readBool();
                        break;
                    case 2:
                        reader.readMessage(message.error, () => message.error = Error.deserialize(reader));
                        break;
                    case 3:
                        reader.readMessage(message.rooms, () => pb_1.Message.addToRepeatedWrapperField(message, 3, Room.deserialize(reader), Room));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): GetRoomsReply {
            return GetRoomsReply.deserialize(bytes);
        }
    }
    export class UpdatePeerRequest extends pb_1.Message {
        constructor(data?: any[] | {
            peer?: Peer;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("peer" in data && data.peer != undefined) {
                    this.peer = data.peer;
                }
            }
        }
        get peer() {
            return pb_1.Message.getWrapperField(this, Peer, 1) as Peer;
        }
        set peer(value: Peer) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        toObject() {
            const data: {
                peer?: ReturnType<typeof Peer.prototype.toObject>;
            } = {};
            if (this.peer != null) {
                data.peer = this.peer.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.peer !== undefined)
                writer.writeMessage(1, this.peer, () => this.peer.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): UpdatePeerRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new UpdatePeerRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.peer, () => message.peer = Peer.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): UpdatePeerRequest {
            return UpdatePeerRequest.deserialize(bytes);
        }
    }
    export class UpdatePeerReply extends pb_1.Message {
        constructor(data?: any[] | {
            success?: boolean;
            error?: Error;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("success" in data && data.success != undefined) {
                    this.success = data.success;
                }
                if ("error" in data && data.error != undefined) {
                    this.error = data.error;
                }
            }
        }
        get success() {
            return pb_1.Message.getField(this, 1) as boolean;
        }
        set success(value: boolean) {
            pb_1.Message.setField(this, 1, value);
        }
        get error() {
            return pb_1.Message.getWrapperField(this, Error, 2) as Error;
        }
        set error(value: Error) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        toObject() {
            const data: {
                success?: boolean;
                error?: ReturnType<typeof Error.prototype.toObject>;
            } = {};
            if (this.success != null) {
                data.success = this.success;
            }
            if (this.error != null) {
                data.error = this.error.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.success !== undefined)
                writer.writeBool(1, this.success);
            if (this.error !== undefined)
                writer.writeMessage(2, this.error, () => this.error.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): UpdatePeerReply {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new UpdatePeerReply();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.success = reader.readBool();
                        break;
                    case 2:
                        reader.readMessage(message.error, () => message.error = Error.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): UpdatePeerReply {
            return UpdatePeerReply.deserialize(bytes);
        }
    }
    export class RemovePeerRequest extends pb_1.Message {
        constructor(data?: any[] | {
            sid?: string;
            uid?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("sid" in data && data.sid != undefined) {
                    this.sid = data.sid;
                }
                if ("uid" in data && data.uid != undefined) {
                    this.uid = data.uid;
                }
            }
        }
        get sid() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set sid(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get uid() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set uid(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        toObject() {
            const data: {
                sid?: string;
                uid?: string;
            } = {};
            if (this.sid != null) {
                data.sid = this.sid;
            }
            if (this.uid != null) {
                data.uid = this.uid;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.sid === "string" && this.sid.length)
                writer.writeString(1, this.sid);
            if (typeof this.uid === "string" && this.uid.length)
                writer.writeString(2, this.uid);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): RemovePeerRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new RemovePeerRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.sid = reader.readString();
                        break;
                    case 2:
                        message.uid = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): RemovePeerRequest {
            return RemovePeerRequest.deserialize(bytes);
        }
    }
    export class RemovePeerReply extends pb_1.Message {
        constructor(data?: any[] | {
            success?: boolean;
            error?: Error;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("success" in data && data.success != undefined) {
                    this.success = data.success;
                }
                if ("error" in data && data.error != undefined) {
                    this.error = data.error;
                }
            }
        }
        get success() {
            return pb_1.Message.getField(this, 1) as boolean;
        }
        set success(value: boolean) {
            pb_1.Message.setField(this, 1, value);
        }
        get error() {
            return pb_1.Message.getWrapperField(this, Error, 2) as Error;
        }
        set error(value: Error) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        toObject() {
            const data: {
                success?: boolean;
                error?: ReturnType<typeof Error.prototype.toObject>;
            } = {};
            if (this.success != null) {
                data.success = this.success;
            }
            if (this.error != null) {
                data.error = this.error.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.success !== undefined)
                writer.writeBool(1, this.success);
            if (this.error !== undefined)
                writer.writeMessage(2, this.error, () => this.error.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): RemovePeerReply {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new RemovePeerReply();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.success = reader.readBool();
                        break;
                    case 2:
                        reader.readMessage(message.error, () => message.error = Error.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): RemovePeerReply {
            return RemovePeerReply.deserialize(bytes);
        }
    }
    export abstract class UnimplementedRoomServiceService {
        static definition = {
            CreateRoom: {
                path: "/room.RoomService/CreateRoom",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: CreateRoomRequest) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => CreateRoomRequest.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: CreateRoomReply) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => CreateRoomReply.deserialize(new Uint8Array(bytes))
            },
            UpdateRoom: {
                path: "/room.RoomService/UpdateRoom",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: UpdateRoomRequest) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => UpdateRoomRequest.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: UpdateRoomReply) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => UpdateRoomReply.deserialize(new Uint8Array(bytes))
            },
            EndRoom: {
                path: "/room.RoomService/EndRoom",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: EndRoomRequest) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => EndRoomRequest.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: EndRoomReply) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => EndRoomReply.deserialize(new Uint8Array(bytes))
            },
            GetRooms: {
                path: "/room.RoomService/GetRooms",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: GetRoomsRequest) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => GetRoomsRequest.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: GetRoomsReply) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => GetRoomsReply.deserialize(new Uint8Array(bytes))
            },
            AddPeer: {
                path: "/room.RoomService/AddPeer",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: AddPeerRequest) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => AddPeerRequest.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: AddPeerReply) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => AddPeerReply.deserialize(new Uint8Array(bytes))
            },
            UpdatePeer: {
                path: "/room.RoomService/UpdatePeer",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: UpdatePeerRequest) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => UpdatePeerRequest.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: UpdatePeerReply) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => UpdatePeerReply.deserialize(new Uint8Array(bytes))
            },
            RemovePeer: {
                path: "/room.RoomService/RemovePeer",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: RemovePeerRequest) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => RemovePeerRequest.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: RemovePeerReply) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => RemovePeerReply.deserialize(new Uint8Array(bytes))
            },
            GetPeers: {
                path: "/room.RoomService/GetPeers",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: GetPeersRequest) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => GetPeersRequest.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: GetPeersReply) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => GetPeersReply.deserialize(new Uint8Array(bytes))
            }
        };
        [method: string]: grpc_1.UntypedHandleCall;
        abstract CreateRoom(call: grpc_1.ServerUnaryCall<CreateRoomRequest, CreateRoomReply>, callback: grpc_1.requestCallback<CreateRoomReply>): void;
        abstract UpdateRoom(call: grpc_1.ServerUnaryCall<UpdateRoomRequest, UpdateRoomReply>, callback: grpc_1.requestCallback<UpdateRoomReply>): void;
        abstract EndRoom(call: grpc_1.ServerUnaryCall<EndRoomRequest, EndRoomReply>, callback: grpc_1.requestCallback<EndRoomReply>): void;
        abstract GetRooms(call: grpc_1.ServerUnaryCall<GetRoomsRequest, GetRoomsReply>, callback: grpc_1.requestCallback<GetRoomsReply>): void;
        abstract AddPeer(call: grpc_1.ServerUnaryCall<AddPeerRequest, AddPeerReply>, callback: grpc_1.requestCallback<AddPeerReply>): void;
        abstract UpdatePeer(call: grpc_1.ServerUnaryCall<UpdatePeerRequest, UpdatePeerReply>, callback: grpc_1.requestCallback<UpdatePeerReply>): void;
        abstract RemovePeer(call: grpc_1.ServerUnaryCall<RemovePeerRequest, RemovePeerReply>, callback: grpc_1.requestCallback<RemovePeerReply>): void;
        abstract GetPeers(call: grpc_1.ServerUnaryCall<GetPeersRequest, GetPeersReply>, callback: grpc_1.requestCallback<GetPeersReply>): void;
    }
    export class RoomServiceClient extends grpc_1.makeGenericClientConstructor(UnimplementedRoomServiceService.definition, "RoomService", {}) {
        constructor(address: string, credentials: grpc_1.ChannelCredentials, options?: Partial<grpc_1.ChannelOptions>) {
            super(address, credentials, options)
        }
        CreateRoom(message: CreateRoomRequest, metadata: grpc_1.Metadata, options: grpc_1.CallOptions, callback: grpc_1.requestCallback<CreateRoomReply>): grpc_1.ClientUnaryCall;
        CreateRoom(message: CreateRoomRequest, metadata: grpc_1.Metadata, callback: grpc_1.requestCallback<CreateRoomReply>): grpc_1.ClientUnaryCall;
        CreateRoom(message: CreateRoomRequest, options: grpc_1.CallOptions, callback: grpc_1.requestCallback<CreateRoomReply>): grpc_1.ClientUnaryCall;
        CreateRoom(message: CreateRoomRequest, callback: grpc_1.requestCallback<CreateRoomReply>): grpc_1.ClientUnaryCall;
        CreateRoom(message: CreateRoomRequest, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<CreateRoomReply>, options?: grpc_1.CallOptions | grpc_1.requestCallback<CreateRoomReply>, callback?: grpc_1.requestCallback<CreateRoomReply>): grpc_1.ClientUnaryCall {
            return super.CreateRoom(message, metadata, options, callback);
        }
        UpdateRoom(message: UpdateRoomRequest, metadata: grpc_1.Metadata, options: grpc_1.CallOptions, callback: grpc_1.requestCallback<UpdateRoomReply>): grpc_1.ClientUnaryCall;
        UpdateRoom(message: UpdateRoomRequest, metadata: grpc_1.Metadata, callback: grpc_1.requestCallback<UpdateRoomReply>): grpc_1.ClientUnaryCall;
        UpdateRoom(message: UpdateRoomRequest, options: grpc_1.CallOptions, callback: grpc_1.requestCallback<UpdateRoomReply>): grpc_1.ClientUnaryCall;
        UpdateRoom(message: UpdateRoomRequest, callback: grpc_1.requestCallback<UpdateRoomReply>): grpc_1.ClientUnaryCall;
        UpdateRoom(message: UpdateRoomRequest, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<UpdateRoomReply>, options?: grpc_1.CallOptions | grpc_1.requestCallback<UpdateRoomReply>, callback?: grpc_1.requestCallback<UpdateRoomReply>): grpc_1.ClientUnaryCall {
            return super.UpdateRoom(message, metadata, options, callback);
        }
        EndRoom(message: EndRoomRequest, metadata: grpc_1.Metadata, options: grpc_1.CallOptions, callback: grpc_1.requestCallback<EndRoomReply>): grpc_1.ClientUnaryCall;
        EndRoom(message: EndRoomRequest, metadata: grpc_1.Metadata, callback: grpc_1.requestCallback<EndRoomReply>): grpc_1.ClientUnaryCall;
        EndRoom(message: EndRoomRequest, options: grpc_1.CallOptions, callback: grpc_1.requestCallback<EndRoomReply>): grpc_1.ClientUnaryCall;
        EndRoom(message: EndRoomRequest, callback: grpc_1.requestCallback<EndRoomReply>): grpc_1.ClientUnaryCall;
        EndRoom(message: EndRoomRequest, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<EndRoomReply>, options?: grpc_1.CallOptions | grpc_1.requestCallback<EndRoomReply>, callback?: grpc_1.requestCallback<EndRoomReply>): grpc_1.ClientUnaryCall {
            return super.EndRoom(message, metadata, options, callback);
        }
        GetRooms(message: GetRoomsRequest, metadata: grpc_1.Metadata, options: grpc_1.CallOptions, callback: grpc_1.requestCallback<GetRoomsReply>): grpc_1.ClientUnaryCall;
        GetRooms(message: GetRoomsRequest, metadata: grpc_1.Metadata, callback: grpc_1.requestCallback<GetRoomsReply>): grpc_1.ClientUnaryCall;
        GetRooms(message: GetRoomsRequest, options: grpc_1.CallOptions, callback: grpc_1.requestCallback<GetRoomsReply>): grpc_1.ClientUnaryCall;
        GetRooms(message: GetRoomsRequest, callback: grpc_1.requestCallback<GetRoomsReply>): grpc_1.ClientUnaryCall;
        GetRooms(message: GetRoomsRequest, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<GetRoomsReply>, options?: grpc_1.CallOptions | grpc_1.requestCallback<GetRoomsReply>, callback?: grpc_1.requestCallback<GetRoomsReply>): grpc_1.ClientUnaryCall {
            return super.GetRooms(message, metadata, options, callback);
        }
        AddPeer(message: AddPeerRequest, metadata: grpc_1.Metadata, options: grpc_1.CallOptions, callback: grpc_1.requestCallback<AddPeerReply>): grpc_1.ClientUnaryCall;
        AddPeer(message: AddPeerRequest, metadata: grpc_1.Metadata, callback: grpc_1.requestCallback<AddPeerReply>): grpc_1.ClientUnaryCall;
        AddPeer(message: AddPeerRequest, options: grpc_1.CallOptions, callback: grpc_1.requestCallback<AddPeerReply>): grpc_1.ClientUnaryCall;
        AddPeer(message: AddPeerRequest, callback: grpc_1.requestCallback<AddPeerReply>): grpc_1.ClientUnaryCall;
        AddPeer(message: AddPeerRequest, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<AddPeerReply>, options?: grpc_1.CallOptions | grpc_1.requestCallback<AddPeerReply>, callback?: grpc_1.requestCallback<AddPeerReply>): grpc_1.ClientUnaryCall {
            return super.AddPeer(message, metadata, options, callback);
        }
        UpdatePeer(message: UpdatePeerRequest, metadata: grpc_1.Metadata, options: grpc_1.CallOptions, callback: grpc_1.requestCallback<UpdatePeerReply>): grpc_1.ClientUnaryCall;
        UpdatePeer(message: UpdatePeerRequest, metadata: grpc_1.Metadata, callback: grpc_1.requestCallback<UpdatePeerReply>): grpc_1.ClientUnaryCall;
        UpdatePeer(message: UpdatePeerRequest, options: grpc_1.CallOptions, callback: grpc_1.requestCallback<UpdatePeerReply>): grpc_1.ClientUnaryCall;
        UpdatePeer(message: UpdatePeerRequest, callback: grpc_1.requestCallback<UpdatePeerReply>): grpc_1.ClientUnaryCall;
        UpdatePeer(message: UpdatePeerRequest, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<UpdatePeerReply>, options?: grpc_1.CallOptions | grpc_1.requestCallback<UpdatePeerReply>, callback?: grpc_1.requestCallback<UpdatePeerReply>): grpc_1.ClientUnaryCall {
            return super.UpdatePeer(message, metadata, options, callback);
        }
        RemovePeer(message: RemovePeerRequest, metadata: grpc_1.Metadata, options: grpc_1.CallOptions, callback: grpc_1.requestCallback<RemovePeerReply>): grpc_1.ClientUnaryCall;
        RemovePeer(message: RemovePeerRequest, metadata: grpc_1.Metadata, callback: grpc_1.requestCallback<RemovePeerReply>): grpc_1.ClientUnaryCall;
        RemovePeer(message: RemovePeerRequest, options: grpc_1.CallOptions, callback: grpc_1.requestCallback<RemovePeerReply>): grpc_1.ClientUnaryCall;
        RemovePeer(message: RemovePeerRequest, callback: grpc_1.requestCallback<RemovePeerReply>): grpc_1.ClientUnaryCall;
        RemovePeer(message: RemovePeerRequest, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<RemovePeerReply>, options?: grpc_1.CallOptions | grpc_1.requestCallback<RemovePeerReply>, callback?: grpc_1.requestCallback<RemovePeerReply>): grpc_1.ClientUnaryCall {
            return super.RemovePeer(message, metadata, options, callback);
        }
        GetPeers(message: GetPeersRequest, metadata: grpc_1.Metadata, options: grpc_1.CallOptions, callback: grpc_1.requestCallback<GetPeersReply>): grpc_1.ClientUnaryCall;
        GetPeers(message: GetPeersRequest, metadata: grpc_1.Metadata, callback: grpc_1.requestCallback<GetPeersReply>): grpc_1.ClientUnaryCall;
        GetPeers(message: GetPeersRequest, options: grpc_1.CallOptions, callback: grpc_1.requestCallback<GetPeersReply>): grpc_1.ClientUnaryCall;
        GetPeers(message: GetPeersRequest, callback: grpc_1.requestCallback<GetPeersReply>): grpc_1.ClientUnaryCall;
        GetPeers(message: GetPeersRequest, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<GetPeersReply>, options?: grpc_1.CallOptions | grpc_1.requestCallback<GetPeersReply>, callback?: grpc_1.requestCallback<GetPeersReply>): grpc_1.ClientUnaryCall {
            return super.GetPeers(message, metadata, options, callback);
        }
    }
    export abstract class UnimplementedRoomSignalService {
        static definition = {
            Signal: {
                path: "/room.RoomSignal/Signal",
                requestStream: true,
                responseStream: true,
                requestSerialize: (message: Request) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => Request.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: Reply) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => Reply.deserialize(new Uint8Array(bytes))
            }
        };
        [method: string]: grpc_1.UntypedHandleCall;
        abstract Signal(call: grpc_1.ServerDuplexStream<Request, Reply>): void;
    }
    export class RoomSignalClient extends grpc_1.makeGenericClientConstructor(UnimplementedRoomSignalService.definition, "RoomSignal", {}) {
        constructor(address: string, credentials: grpc_1.ChannelCredentials, options?: Partial<grpc_1.ChannelOptions>) {
            super(address, credentials, options)
        }
        Signal(metadata: grpc_1.Metadata, options?: grpc_1.CallOptions): grpc_1.ClientDuplexStream<Request, Reply>;
        Signal(options?: grpc_1.CallOptions): grpc_1.ClientDuplexStream<Request, Reply>;
        Signal(metadata?: grpc_1.Metadata | grpc_1.CallOptions, options?: grpc_1.CallOptions): grpc_1.ClientDuplexStream<Request, Reply> {
            return super.Signal(metadata, options);
        }
    }
}
