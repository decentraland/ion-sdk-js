/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 3.12.4
 * source: proto/rtc/rtc.proto
 * git: https://github.com/thesayyn/protoc-gen-ts
 * buymeacoffee: https://www.buymeacoffee.com/thesayyn
 *  */
import * as pb_1 from "google-protobuf";
import * as grpc_1 from "@grpc/grpc-js";
export namespace rtc {
    export enum Target {
        PUBLISHER = 0,
        SUBSCRIBER = 1
    }
    export enum MediaType {
        MediaUnknown = 0,
        UserMedia = 1,
        ScreenCapture = 2,
        Cavans = 3,
        Streaming = 4,
        VoIP = 5
    }
    export class JoinRequest extends pb_1.Message {
        constructor(data?: any[] | {
            sid?: string;
            uid?: string;
            config?: Map<string, string>;
            description?: SessionDescription;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("sid" in data && data.sid != undefined) {
                    this.sid = data.sid;
                }
                if ("uid" in data && data.uid != undefined) {
                    this.uid = data.uid;
                }
                if ("config" in data && data.config != undefined) {
                    this.config = data.config;
                }
                if ("description" in data && data.description != undefined) {
                    this.description = data.description;
                }
            }
            if (!this.config)
                this.config = new Map()
        }
        get sid() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set sid(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get uid() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set uid(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get config() {
            return pb_1.Message.getField(this, 3) as any as Map<string, string>;
        }
        set config(value: Map<string, string>) {
            pb_1.Message.setField(this, 3, value as any);
        }
        get description() {
            return pb_1.Message.getWrapperField(this, SessionDescription, 4) as SessionDescription;
        }
        set description(value: SessionDescription) {
            pb_1.Message.setWrapperField(this, 4, value);
        }
        toObject() {
            const data: {
                sid?: string;
                uid?: string;
                config?: {
                    [key: string]: string;
                };
                description?: ReturnType<typeof SessionDescription.prototype.toObject>;
            } = {};
            if (this.sid != null) {
                data.sid = this.sid;
            }
            if (this.uid != null) {
                data.uid = this.uid;
            }
            if (this.config.size > 0) {
                data.config = Object.fromEntries(this.config);
            }
            if (this.description != null) {
                data.description = this.description.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.sid === "string" && this.sid.length)
                writer.writeString(1, this.sid);
            if (typeof this.uid === "string" && this.uid.length)
                writer.writeString(2, this.uid);
            for (const [key, value] of this.config) {
                writer.writeMessage(3, this.config, () => {
                    writer.writeString(1, key);
                    writer.writeString(2, value);
                })
            }
            if (this.description !== undefined)
                writer.writeMessage(4, this.description, () => this.description.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): JoinRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new JoinRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.sid = reader.readString();
                        break;
                    case 2:
                        message.uid = reader.readString();
                        break;
                    case 3:
                        reader.readMessage(message, () => (pb_1.Map as any).deserializeBinary(message.config, reader, reader.readString, reader.readString));
                        break;
                    case 4:
                        reader.readMessage(message.description, () => message.description = SessionDescription.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): JoinRequest {
            return JoinRequest.deserialize(bytes);
        }
    }
    export class JoinReply extends pb_1.Message {
        constructor(data?: any[] | {
            success?: boolean;
            error?: Error;
            description?: SessionDescription;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("success" in data && data.success != undefined) {
                    this.success = data.success;
                }
                if ("error" in data && data.error != undefined) {
                    this.error = data.error;
                }
                if ("description" in data && data.description != undefined) {
                    this.description = data.description;
                }
            }
        }
        get success() {
            return pb_1.Message.getField(this, 1) as boolean;
        }
        set success(value: boolean) {
            pb_1.Message.setField(this, 1, value);
        }
        get error() {
            return pb_1.Message.getWrapperField(this, Error, 2) as Error;
        }
        set error(value: Error) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get description() {
            return pb_1.Message.getWrapperField(this, SessionDescription, 3) as SessionDescription;
        }
        set description(value: SessionDescription) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        toObject() {
            const data: {
                success?: boolean;
                error?: ReturnType<typeof Error.prototype.toObject>;
                description?: ReturnType<typeof SessionDescription.prototype.toObject>;
            } = {};
            if (this.success != null) {
                data.success = this.success;
            }
            if (this.error != null) {
                data.error = this.error.toObject();
            }
            if (this.description != null) {
                data.description = this.description.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.success !== undefined)
                writer.writeBool(1, this.success);
            if (this.error !== undefined)
                writer.writeMessage(2, this.error, () => this.error.serialize(writer));
            if (this.description !== undefined)
                writer.writeMessage(3, this.description, () => this.description.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): JoinReply {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new JoinReply();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.success = reader.readBool();
                        break;
                    case 2:
                        reader.readMessage(message.error, () => message.error = Error.deserialize(reader));
                        break;
                    case 3:
                        reader.readMessage(message.description, () => message.description = SessionDescription.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): JoinReply {
            return JoinReply.deserialize(bytes);
        }
    }
    export class VideoInfo extends pb_1.Message {
        constructor(data?: any[] | {
            width?: number;
            height?: number;
            frameRate?: number;
            simulcast?: Map<string, string>;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("width" in data && data.width != undefined) {
                    this.width = data.width;
                }
                if ("height" in data && data.height != undefined) {
                    this.height = data.height;
                }
                if ("frameRate" in data && data.frameRate != undefined) {
                    this.frameRate = data.frameRate;
                }
                if ("simulcast" in data && data.simulcast != undefined) {
                    this.simulcast = data.simulcast;
                }
            }
            if (!this.simulcast)
                this.simulcast = new Map()
        }
        get width() {
            return pb_1.Message.getField(this, 1) as number;
        }
        set width(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get height() {
            return pb_1.Message.getField(this, 2) as number;
        }
        set height(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get frameRate() {
            return pb_1.Message.getField(this, 3) as number;
        }
        set frameRate(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get simulcast() {
            return pb_1.Message.getField(this, 4) as any as Map<string, string>;
        }
        set simulcast(value: Map<string, string>) {
            pb_1.Message.setField(this, 4, value as any);
        }
        toObject() {
            const data: {
                width?: number;
                height?: number;
                frameRate?: number;
                simulcast?: {
                    [key: string]: string;
                };
            } = {};
            if (this.width != null) {
                data.width = this.width;
            }
            if (this.height != null) {
                data.height = this.height;
            }
            if (this.frameRate != null) {
                data.frameRate = this.frameRate;
            }
            if (this.simulcast.size > 0) {
                data.simulcast = Object.fromEntries(this.simulcast);
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.width !== undefined)
                writer.writeUint32(1, this.width);
            if (this.height !== undefined)
                writer.writeUint32(2, this.height);
            if (this.frameRate !== undefined)
                writer.writeUint32(3, this.frameRate);
            for (const [key, value] of this.simulcast) {
                writer.writeMessage(4, this.simulcast, () => {
                    writer.writeString(1, key);
                    writer.writeString(2, value);
                })
            }
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): VideoInfo {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new VideoInfo();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.width = reader.readUint32();
                        break;
                    case 2:
                        message.height = reader.readUint32();
                        break;
                    case 3:
                        message.frameRate = reader.readUint32();
                        break;
                    case 4:
                        reader.readMessage(message, () => (pb_1.Map as any).deserializeBinary(message.simulcast, reader, reader.readString, reader.readString));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): VideoInfo {
            return VideoInfo.deserialize(bytes);
        }
    }
    export class TrackInfo extends pb_1.Message {
        constructor(data?: any[] | {
            id?: string;
            kind?: string;
            muted?: boolean;
            type?: MediaType;
            streamId?: string;
            label?: string;
            videoInfo?: VideoInfo;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("id" in data && data.id != undefined) {
                    this.id = data.id;
                }
                if ("kind" in data && data.kind != undefined) {
                    this.kind = data.kind;
                }
                if ("muted" in data && data.muted != undefined) {
                    this.muted = data.muted;
                }
                if ("type" in data && data.type != undefined) {
                    this.type = data.type;
                }
                if ("streamId" in data && data.streamId != undefined) {
                    this.streamId = data.streamId;
                }
                if ("label" in data && data.label != undefined) {
                    this.label = data.label;
                }
                if ("videoInfo" in data && data.videoInfo != undefined) {
                    this.videoInfo = data.videoInfo;
                }
            }
        }
        get id() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set id(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get kind() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set kind(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get muted() {
            return pb_1.Message.getField(this, 3) as boolean;
        }
        set muted(value: boolean) {
            pb_1.Message.setField(this, 3, value);
        }
        get type() {
            return pb_1.Message.getField(this, 4) as MediaType;
        }
        set type(value: MediaType) {
            pb_1.Message.setField(this, 4, value);
        }
        get streamId() {
            return pb_1.Message.getField(this, 5) as string;
        }
        set streamId(value: string) {
            pb_1.Message.setField(this, 5, value);
        }
        get label() {
            return pb_1.Message.getField(this, 6) as string;
        }
        set label(value: string) {
            pb_1.Message.setField(this, 6, value);
        }
        get videoInfo() {
            return pb_1.Message.getWrapperField(this, VideoInfo, 7) as VideoInfo;
        }
        set videoInfo(value: VideoInfo) {
            pb_1.Message.setWrapperField(this, 7, value);
        }
        toObject() {
            const data: {
                id?: string;
                kind?: string;
                muted?: boolean;
                type?: MediaType;
                streamId?: string;
                label?: string;
                videoInfo?: ReturnType<typeof VideoInfo.prototype.toObject>;
            } = {};
            if (this.id != null) {
                data.id = this.id;
            }
            if (this.kind != null) {
                data.kind = this.kind;
            }
            if (this.muted != null) {
                data.muted = this.muted;
            }
            if (this.type != null) {
                data.type = this.type;
            }
            if (this.streamId != null) {
                data.streamId = this.streamId;
            }
            if (this.label != null) {
                data.label = this.label;
            }
            if (this.videoInfo != null) {
                data.videoInfo = this.videoInfo.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.id === "string" && this.id.length)
                writer.writeString(1, this.id);
            if (typeof this.kind === "string" && this.kind.length)
                writer.writeString(2, this.kind);
            if (this.muted !== undefined)
                writer.writeBool(3, this.muted);
            if (this.type !== undefined)
                writer.writeEnum(4, this.type);
            if (typeof this.streamId === "string" && this.streamId.length)
                writer.writeString(5, this.streamId);
            if (typeof this.label === "string" && this.label.length)
                writer.writeString(6, this.label);
            if (this.videoInfo !== undefined)
                writer.writeMessage(7, this.videoInfo, () => this.videoInfo.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): TrackInfo {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new TrackInfo();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.id = reader.readString();
                        break;
                    case 2:
                        message.kind = reader.readString();
                        break;
                    case 3:
                        message.muted = reader.readBool();
                        break;
                    case 4:
                        message.type = reader.readEnum();
                        break;
                    case 5:
                        message.streamId = reader.readString();
                        break;
                    case 6:
                        message.label = reader.readString();
                        break;
                    case 7:
                        reader.readMessage(message.videoInfo, () => message.videoInfo = VideoInfo.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): TrackInfo {
            return TrackInfo.deserialize(bytes);
        }
    }
    export class SessionDescription extends pb_1.Message {
        constructor(data?: any[] | {
            target?: Target;
            type?: string;
            sdp?: string;
            trackInfos?: TrackInfo[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [4], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("target" in data && data.target != undefined) {
                    this.target = data.target;
                }
                if ("type" in data && data.type != undefined) {
                    this.type = data.type;
                }
                if ("sdp" in data && data.sdp != undefined) {
                    this.sdp = data.sdp;
                }
                if ("trackInfos" in data && data.trackInfos != undefined) {
                    this.trackInfos = data.trackInfos;
                }
            }
        }
        get target() {
            return pb_1.Message.getField(this, 1) as Target;
        }
        set target(value: Target) {
            pb_1.Message.setField(this, 1, value);
        }
        get type() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set type(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get sdp() {
            return pb_1.Message.getField(this, 3) as string;
        }
        set sdp(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get trackInfos() {
            return pb_1.Message.getRepeatedWrapperField(this, TrackInfo, 4) as TrackInfo[];
        }
        set trackInfos(value: TrackInfo[]) {
            pb_1.Message.setRepeatedWrapperField(this, 4, value);
        }
        toObject() {
            const data: {
                target?: Target;
                type?: string;
                sdp?: string;
                trackInfos?: ReturnType<typeof TrackInfo.prototype.toObject>[];
            } = {};
            if (this.target != null) {
                data.target = this.target;
            }
            if (this.type != null) {
                data.type = this.type;
            }
            if (this.sdp != null) {
                data.sdp = this.sdp;
            }
            if (this.trackInfos != null) {
                data.trackInfos = this.trackInfos.map((item: TrackInfo) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.target !== undefined)
                writer.writeEnum(1, this.target);
            if (typeof this.type === "string" && this.type.length)
                writer.writeString(2, this.type);
            if (typeof this.sdp === "string" && this.sdp.length)
                writer.writeString(3, this.sdp);
            if (this.trackInfos !== undefined)
                writer.writeRepeatedMessage(4, this.trackInfos, (item: TrackInfo) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SessionDescription {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SessionDescription();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.target = reader.readEnum();
                        break;
                    case 2:
                        message.type = reader.readString();
                        break;
                    case 3:
                        message.sdp = reader.readString();
                        break;
                    case 4:
                        reader.readMessage(message.trackInfos, () => pb_1.Message.addToRepeatedWrapperField(message, 4, TrackInfo.deserialize(reader), TrackInfo));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SessionDescription {
            return SessionDescription.deserialize(bytes);
        }
    }
    export class Trickle extends pb_1.Message {
        constructor(data?: any[] | {
            target?: Target;
            init?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("target" in data && data.target != undefined) {
                    this.target = data.target;
                }
                if ("init" in data && data.init != undefined) {
                    this.init = data.init;
                }
            }
        }
        get target() {
            return pb_1.Message.getField(this, 1) as Target;
        }
        set target(value: Target) {
            pb_1.Message.setField(this, 1, value);
        }
        get init() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set init(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        toObject() {
            const data: {
                target?: Target;
                init?: string;
            } = {};
            if (this.target != null) {
                data.target = this.target;
            }
            if (this.init != null) {
                data.init = this.init;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.target !== undefined)
                writer.writeEnum(1, this.target);
            if (typeof this.init === "string" && this.init.length)
                writer.writeString(2, this.init);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Trickle {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Trickle();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.target = reader.readEnum();
                        break;
                    case 2:
                        message.init = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Trickle {
            return Trickle.deserialize(bytes);
        }
    }
    export class Error extends pb_1.Message {
        constructor(data?: any[] | {
            code?: number;
            reason?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("code" in data && data.code != undefined) {
                    this.code = data.code;
                }
                if ("reason" in data && data.reason != undefined) {
                    this.reason = data.reason;
                }
            }
        }
        get code() {
            return pb_1.Message.getField(this, 1) as number;
        }
        set code(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get reason() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set reason(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        toObject() {
            const data: {
                code?: number;
                reason?: string;
            } = {};
            if (this.code != null) {
                data.code = this.code;
            }
            if (this.reason != null) {
                data.reason = this.reason;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.code !== undefined)
                writer.writeInt32(1, this.code);
            if (typeof this.reason === "string" && this.reason.length)
                writer.writeString(2, this.reason);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Error {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Error();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.code = reader.readInt32();
                        break;
                    case 2:
                        message.reason = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Error {
            return Error.deserialize(bytes);
        }
    }
    export class TrackEvent extends pb_1.Message {
        constructor(data?: any[] | {
            state?: TrackEvent.State;
            uid?: string;
            tracks?: TrackInfo[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [3], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("state" in data && data.state != undefined) {
                    this.state = data.state;
                }
                if ("uid" in data && data.uid != undefined) {
                    this.uid = data.uid;
                }
                if ("tracks" in data && data.tracks != undefined) {
                    this.tracks = data.tracks;
                }
            }
        }
        get state() {
            return pb_1.Message.getField(this, 1) as TrackEvent.State;
        }
        set state(value: TrackEvent.State) {
            pb_1.Message.setField(this, 1, value);
        }
        get uid() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set uid(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get tracks() {
            return pb_1.Message.getRepeatedWrapperField(this, TrackInfo, 3) as TrackInfo[];
        }
        set tracks(value: TrackInfo[]) {
            pb_1.Message.setRepeatedWrapperField(this, 3, value);
        }
        toObject() {
            const data: {
                state?: TrackEvent.State;
                uid?: string;
                tracks?: ReturnType<typeof TrackInfo.prototype.toObject>[];
            } = {};
            if (this.state != null) {
                data.state = this.state;
            }
            if (this.uid != null) {
                data.uid = this.uid;
            }
            if (this.tracks != null) {
                data.tracks = this.tracks.map((item: TrackInfo) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.state !== undefined)
                writer.writeEnum(1, this.state);
            if (typeof this.uid === "string" && this.uid.length)
                writer.writeString(2, this.uid);
            if (this.tracks !== undefined)
                writer.writeRepeatedMessage(3, this.tracks, (item: TrackInfo) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): TrackEvent {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new TrackEvent();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.state = reader.readEnum();
                        break;
                    case 2:
                        message.uid = reader.readString();
                        break;
                    case 3:
                        reader.readMessage(message.tracks, () => pb_1.Message.addToRepeatedWrapperField(message, 3, TrackInfo.deserialize(reader), TrackInfo));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): TrackEvent {
            return TrackEvent.deserialize(bytes);
        }
    }
    export namespace TrackEvent {
        export enum State {
            ADD = 0,
            UPDATE = 1,
            REMOVE = 2
        }
    }
    export class SubscriptionRequest extends pb_1.Message {
        constructor(data?: any[] | {
            trackIds?: string[];
            subscribe?: boolean;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("trackIds" in data && data.trackIds != undefined) {
                    this.trackIds = data.trackIds;
                }
                if ("subscribe" in data && data.subscribe != undefined) {
                    this.subscribe = data.subscribe;
                }
            }
        }
        get trackIds() {
            return pb_1.Message.getField(this, 1) as string[];
        }
        set trackIds(value: string[]) {
            pb_1.Message.setField(this, 1, value);
        }
        get subscribe() {
            return pb_1.Message.getField(this, 2) as boolean;
        }
        set subscribe(value: boolean) {
            pb_1.Message.setField(this, 2, value);
        }
        toObject() {
            const data: {
                trackIds?: string[];
                subscribe?: boolean;
            } = {};
            if (this.trackIds != null) {
                data.trackIds = this.trackIds;
            }
            if (this.subscribe != null) {
                data.subscribe = this.subscribe;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.trackIds !== undefined)
                writer.writeRepeatedString(1, this.trackIds);
            if (this.subscribe !== undefined)
                writer.writeBool(2, this.subscribe);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SubscriptionRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SubscriptionRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        pb_1.Message.addToRepeatedField(message, 1, reader.readString());
                        break;
                    case 2:
                        message.subscribe = reader.readBool();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SubscriptionRequest {
            return SubscriptionRequest.deserialize(bytes);
        }
    }
    export class SubscriptionReply extends pb_1.Message {
        constructor(data?: any[] | {
            success?: boolean;
            error?: Error;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("success" in data && data.success != undefined) {
                    this.success = data.success;
                }
                if ("error" in data && data.error != undefined) {
                    this.error = data.error;
                }
            }
        }
        get success() {
            return pb_1.Message.getField(this, 1) as boolean;
        }
        set success(value: boolean) {
            pb_1.Message.setField(this, 1, value);
        }
        get error() {
            return pb_1.Message.getWrapperField(this, Error, 2) as Error;
        }
        set error(value: Error) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        toObject() {
            const data: {
                success?: boolean;
                error?: ReturnType<typeof Error.prototype.toObject>;
            } = {};
            if (this.success != null) {
                data.success = this.success;
            }
            if (this.error != null) {
                data.error = this.error.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.success !== undefined)
                writer.writeBool(1, this.success);
            if (this.error !== undefined)
                writer.writeMessage(2, this.error, () => this.error.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SubscriptionReply {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SubscriptionReply();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.success = reader.readBool();
                        break;
                    case 2:
                        reader.readMessage(message.error, () => message.error = Error.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SubscriptionReply {
            return SubscriptionReply.deserialize(bytes);
        }
    }
    export class UpdateTrackRequest extends pb_1.Message {
        constructor(data?: any[] | {
            tracks?: TrackInfo[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("tracks" in data && data.tracks != undefined) {
                    this.tracks = data.tracks;
                }
            }
        }
        get tracks() {
            return pb_1.Message.getRepeatedWrapperField(this, TrackInfo, 1) as TrackInfo[];
        }
        set tracks(value: TrackInfo[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        toObject() {
            const data: {
                tracks?: ReturnType<typeof TrackInfo.prototype.toObject>[];
            } = {};
            if (this.tracks != null) {
                data.tracks = this.tracks.map((item: TrackInfo) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.tracks !== undefined)
                writer.writeRepeatedMessage(1, this.tracks, (item: TrackInfo) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): UpdateTrackRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new UpdateTrackRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.tracks, () => pb_1.Message.addToRepeatedWrapperField(message, 1, TrackInfo.deserialize(reader), TrackInfo));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): UpdateTrackRequest {
            return UpdateTrackRequest.deserialize(bytes);
        }
    }
    export class UpdateTrackReply extends pb_1.Message {
        constructor(data?: any[] | {
            success?: boolean;
            error?: Error;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("success" in data && data.success != undefined) {
                    this.success = data.success;
                }
                if ("error" in data && data.error != undefined) {
                    this.error = data.error;
                }
            }
        }
        get success() {
            return pb_1.Message.getField(this, 1) as boolean;
        }
        set success(value: boolean) {
            pb_1.Message.setField(this, 1, value);
        }
        get error() {
            return pb_1.Message.getWrapperField(this, Error, 2) as Error;
        }
        set error(value: Error) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        toObject() {
            const data: {
                success?: boolean;
                error?: ReturnType<typeof Error.prototype.toObject>;
            } = {};
            if (this.success != null) {
                data.success = this.success;
            }
            if (this.error != null) {
                data.error = this.error.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.success !== undefined)
                writer.writeBool(1, this.success);
            if (this.error !== undefined)
                writer.writeMessage(2, this.error, () => this.error.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): UpdateTrackReply {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new UpdateTrackReply();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.success = reader.readBool();
                        break;
                    case 2:
                        reader.readMessage(message.error, () => message.error = Error.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): UpdateTrackReply {
            return UpdateTrackReply.deserialize(bytes);
        }
    }
    export class Request extends pb_1.Message {
        constructor(data?: any[] | ({} & (({
            join?: JoinRequest;
            description?: never;
            trickle?: never;
            subscription?: never;
            updateTrack?: never;
        } | {
            join?: never;
            description?: SessionDescription;
            trickle?: never;
            subscription?: never;
            updateTrack?: never;
        } | {
            join?: never;
            description?: never;
            trickle?: Trickle;
            subscription?: never;
            updateTrack?: never;
        } | {
            join?: never;
            description?: never;
            trickle?: never;
            subscription?: SubscriptionRequest;
            updateTrack?: never;
        } | {
            join?: never;
            description?: never;
            trickle?: never;
            subscription?: never;
            updateTrack?: UpdateTrackRequest;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], [[1, 2, 3, 4, 5]]);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("join" in data && data.join != undefined) {
                    this.join = data.join;
                }
                if ("description" in data && data.description != undefined) {
                    this.description = data.description;
                }
                if ("trickle" in data && data.trickle != undefined) {
                    this.trickle = data.trickle;
                }
                if ("subscription" in data && data.subscription != undefined) {
                    this.subscription = data.subscription;
                }
                if ("updateTrack" in data && data.updateTrack != undefined) {
                    this.updateTrack = data.updateTrack;
                }
            }
        }
        get join() {
            return pb_1.Message.getWrapperField(this, JoinRequest, 1) as JoinRequest;
        }
        set join(value: JoinRequest) {
            pb_1.Message.setOneofWrapperField(this, 1, [1, 2, 3, 4, 5], value);
        }
        get description() {
            return pb_1.Message.getWrapperField(this, SessionDescription, 2) as SessionDescription;
        }
        set description(value: SessionDescription) {
            pb_1.Message.setOneofWrapperField(this, 2, [1, 2, 3, 4, 5], value);
        }
        get trickle() {
            return pb_1.Message.getWrapperField(this, Trickle, 3) as Trickle;
        }
        set trickle(value: Trickle) {
            pb_1.Message.setOneofWrapperField(this, 3, [1, 2, 3, 4, 5], value);
        }
        get subscription() {
            return pb_1.Message.getWrapperField(this, SubscriptionRequest, 4) as SubscriptionRequest;
        }
        set subscription(value: SubscriptionRequest) {
            pb_1.Message.setOneofWrapperField(this, 4, [1, 2, 3, 4, 5], value);
        }
        get updateTrack() {
            return pb_1.Message.getWrapperField(this, UpdateTrackRequest, 5) as UpdateTrackRequest;
        }
        set updateTrack(value: UpdateTrackRequest) {
            pb_1.Message.setOneofWrapperField(this, 5, [1, 2, 3, 4, 5], value);
        }
        get payload() {
            const cases: {
                [index: number]: "none" | "join" | "description" | "trickle" | "subscription" | "updateTrack";
            } = {
                0: "none",
                1: "join",
                2: "description",
                3: "trickle",
                4: "subscription",
                5: "updateTrack"
            };
            return cases[pb_1.Message.computeOneofCase(this, [1, 2, 3, 4, 5])];
        }
        toObject() {
            const data: {
                join?: ReturnType<typeof JoinRequest.prototype.toObject>;
                description?: ReturnType<typeof SessionDescription.prototype.toObject>;
                trickle?: ReturnType<typeof Trickle.prototype.toObject>;
                subscription?: ReturnType<typeof SubscriptionRequest.prototype.toObject>;
                updateTrack?: ReturnType<typeof UpdateTrackRequest.prototype.toObject>;
            } = {};
            if (this.join != null) {
                data.join = this.join.toObject();
            }
            if (this.description != null) {
                data.description = this.description.toObject();
            }
            if (this.trickle != null) {
                data.trickle = this.trickle.toObject();
            }
            if (this.subscription != null) {
                data.subscription = this.subscription.toObject();
            }
            if (this.updateTrack != null) {
                data.updateTrack = this.updateTrack.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.join !== undefined)
                writer.writeMessage(1, this.join, () => this.join.serialize(writer));
            if (this.description !== undefined)
                writer.writeMessage(2, this.description, () => this.description.serialize(writer));
            if (this.trickle !== undefined)
                writer.writeMessage(3, this.trickle, () => this.trickle.serialize(writer));
            if (this.subscription !== undefined)
                writer.writeMessage(4, this.subscription, () => this.subscription.serialize(writer));
            if (this.updateTrack !== undefined)
                writer.writeMessage(5, this.updateTrack, () => this.updateTrack.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Request {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Request();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.join, () => message.join = JoinRequest.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.description, () => message.description = SessionDescription.deserialize(reader));
                        break;
                    case 3:
                        reader.readMessage(message.trickle, () => message.trickle = Trickle.deserialize(reader));
                        break;
                    case 4:
                        reader.readMessage(message.subscription, () => message.subscription = SubscriptionRequest.deserialize(reader));
                        break;
                    case 5:
                        reader.readMessage(message.updateTrack, () => message.updateTrack = UpdateTrackRequest.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Request {
            return Request.deserialize(bytes);
        }
    }
    export class Reply extends pb_1.Message {
        constructor(data?: any[] | ({} & (({
            join?: JoinReply;
            description?: never;
            trickle?: never;
            trackEvent?: never;
            subscription?: never;
            updateTrack?: never;
            error?: never;
        } | {
            join?: never;
            description?: SessionDescription;
            trickle?: never;
            trackEvent?: never;
            subscription?: never;
            updateTrack?: never;
            error?: never;
        } | {
            join?: never;
            description?: never;
            trickle?: Trickle;
            trackEvent?: never;
            subscription?: never;
            updateTrack?: never;
            error?: never;
        } | {
            join?: never;
            description?: never;
            trickle?: never;
            trackEvent?: TrackEvent;
            subscription?: never;
            updateTrack?: never;
            error?: never;
        } | {
            join?: never;
            description?: never;
            trickle?: never;
            trackEvent?: never;
            subscription?: SubscriptionReply;
            updateTrack?: never;
            error?: never;
        } | {
            join?: never;
            description?: never;
            trickle?: never;
            trackEvent?: never;
            subscription?: never;
            updateTrack?: UpdateTrackReply;
            error?: never;
        } | {
            join?: never;
            description?: never;
            trickle?: never;
            trackEvent?: never;
            subscription?: never;
            updateTrack?: never;
            error?: Error;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], [[1, 2, 3, 4, 5, 6, 7]]);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("join" in data && data.join != undefined) {
                    this.join = data.join;
                }
                if ("description" in data && data.description != undefined) {
                    this.description = data.description;
                }
                if ("trickle" in data && data.trickle != undefined) {
                    this.trickle = data.trickle;
                }
                if ("trackEvent" in data && data.trackEvent != undefined) {
                    this.trackEvent = data.trackEvent;
                }
                if ("subscription" in data && data.subscription != undefined) {
                    this.subscription = data.subscription;
                }
                if ("updateTrack" in data && data.updateTrack != undefined) {
                    this.updateTrack = data.updateTrack;
                }
                if ("error" in data && data.error != undefined) {
                    this.error = data.error;
                }
            }
        }
        get join() {
            return pb_1.Message.getWrapperField(this, JoinReply, 1) as JoinReply;
        }
        set join(value: JoinReply) {
            pb_1.Message.setOneofWrapperField(this, 1, [1, 2, 3, 4, 5, 6, 7], value);
        }
        get description() {
            return pb_1.Message.getWrapperField(this, SessionDescription, 2) as SessionDescription;
        }
        set description(value: SessionDescription) {
            pb_1.Message.setOneofWrapperField(this, 2, [1, 2, 3, 4, 5, 6, 7], value);
        }
        get trickle() {
            return pb_1.Message.getWrapperField(this, Trickle, 3) as Trickle;
        }
        set trickle(value: Trickle) {
            pb_1.Message.setOneofWrapperField(this, 3, [1, 2, 3, 4, 5, 6, 7], value);
        }
        get trackEvent() {
            return pb_1.Message.getWrapperField(this, TrackEvent, 4) as TrackEvent;
        }
        set trackEvent(value: TrackEvent) {
            pb_1.Message.setOneofWrapperField(this, 4, [1, 2, 3, 4, 5, 6, 7], value);
        }
        get subscription() {
            return pb_1.Message.getWrapperField(this, SubscriptionReply, 5) as SubscriptionReply;
        }
        set subscription(value: SubscriptionReply) {
            pb_1.Message.setOneofWrapperField(this, 5, [1, 2, 3, 4, 5, 6, 7], value);
        }
        get updateTrack() {
            return pb_1.Message.getWrapperField(this, UpdateTrackReply, 6) as UpdateTrackReply;
        }
        set updateTrack(value: UpdateTrackReply) {
            pb_1.Message.setOneofWrapperField(this, 6, [1, 2, 3, 4, 5, 6, 7], value);
        }
        get error() {
            return pb_1.Message.getWrapperField(this, Error, 7) as Error;
        }
        set error(value: Error) {
            pb_1.Message.setOneofWrapperField(this, 7, [1, 2, 3, 4, 5, 6, 7], value);
        }
        get payload() {
            const cases: {
                [index: number]: "none" | "join" | "description" | "trickle" | "trackEvent" | "subscription" | "updateTrack" | "error";
            } = {
                0: "none",
                1: "join",
                2: "description",
                3: "trickle",
                4: "trackEvent",
                5: "subscription",
                6: "updateTrack",
                7: "error"
            };
            return cases[pb_1.Message.computeOneofCase(this, [1, 2, 3, 4, 5, 6, 7])];
        }
        toObject() {
            const data: {
                join?: ReturnType<typeof JoinReply.prototype.toObject>;
                description?: ReturnType<typeof SessionDescription.prototype.toObject>;
                trickle?: ReturnType<typeof Trickle.prototype.toObject>;
                trackEvent?: ReturnType<typeof TrackEvent.prototype.toObject>;
                subscription?: ReturnType<typeof SubscriptionReply.prototype.toObject>;
                updateTrack?: ReturnType<typeof UpdateTrackReply.prototype.toObject>;
                error?: ReturnType<typeof Error.prototype.toObject>;
            } = {};
            if (this.join != null) {
                data.join = this.join.toObject();
            }
            if (this.description != null) {
                data.description = this.description.toObject();
            }
            if (this.trickle != null) {
                data.trickle = this.trickle.toObject();
            }
            if (this.trackEvent != null) {
                data.trackEvent = this.trackEvent.toObject();
            }
            if (this.subscription != null) {
                data.subscription = this.subscription.toObject();
            }
            if (this.updateTrack != null) {
                data.updateTrack = this.updateTrack.toObject();
            }
            if (this.error != null) {
                data.error = this.error.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.join !== undefined)
                writer.writeMessage(1, this.join, () => this.join.serialize(writer));
            if (this.description !== undefined)
                writer.writeMessage(2, this.description, () => this.description.serialize(writer));
            if (this.trickle !== undefined)
                writer.writeMessage(3, this.trickle, () => this.trickle.serialize(writer));
            if (this.trackEvent !== undefined)
                writer.writeMessage(4, this.trackEvent, () => this.trackEvent.serialize(writer));
            if (this.subscription !== undefined)
                writer.writeMessage(5, this.subscription, () => this.subscription.serialize(writer));
            if (this.updateTrack !== undefined)
                writer.writeMessage(6, this.updateTrack, () => this.updateTrack.serialize(writer));
            if (this.error !== undefined)
                writer.writeMessage(7, this.error, () => this.error.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Reply {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Reply();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.join, () => message.join = JoinReply.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.description, () => message.description = SessionDescription.deserialize(reader));
                        break;
                    case 3:
                        reader.readMessage(message.trickle, () => message.trickle = Trickle.deserialize(reader));
                        break;
                    case 4:
                        reader.readMessage(message.trackEvent, () => message.trackEvent = TrackEvent.deserialize(reader));
                        break;
                    case 5:
                        reader.readMessage(message.subscription, () => message.subscription = SubscriptionReply.deserialize(reader));
                        break;
                    case 6:
                        reader.readMessage(message.updateTrack, () => message.updateTrack = UpdateTrackReply.deserialize(reader));
                        break;
                    case 7:
                        reader.readMessage(message.error, () => message.error = Error.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Reply {
            return Reply.deserialize(bytes);
        }
    }
    export abstract class UnimplementedRTCService {
        static definition = {
            Signal: {
                path: "/rtc.RTC/Signal",
                requestStream: true,
                responseStream: true,
                requestSerialize: (message: Request) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => Request.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: Reply) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => Reply.deserialize(new Uint8Array(bytes))
            }
        };
        [method: string]: grpc_1.UntypedHandleCall;
        abstract Signal(call: grpc_1.ServerDuplexStream<Request, Reply>): void;
    }
    export class RTCClient extends grpc_1.makeGenericClientConstructor(UnimplementedRTCService.definition, "RTC", {}) {
        constructor(address: string, credentials: grpc_1.ChannelCredentials, options?: Partial<grpc_1.ChannelOptions>) {
            super(address, credentials, options)
        }
        Signal(metadata: grpc_1.Metadata, options?: grpc_1.CallOptions): grpc_1.ClientDuplexStream<Request, Reply>;
        Signal(options?: grpc_1.CallOptions): grpc_1.ClientDuplexStream<Request, Reply>;
        Signal(metadata?: grpc_1.Metadata | grpc_1.CallOptions, options?: grpc_1.CallOptions): grpc_1.ClientDuplexStream<Request, Reply> {
            return super.Signal(metadata, options);
        }
    }
}
